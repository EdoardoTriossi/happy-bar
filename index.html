<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="img/32px_Vue.js_Logo_2.svg" />
    <title>React un framework per applicazioni WEB</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" />
    <link rel="stylesheet" href="css\style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism.min.css" />
  </head>

  <body>
    <!-- Navigation -->
    <div id="app" v-cloak>
      <a id="top"></a>

      <nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary">
        <div class="container-fluid">
          <li class="nav-item">
            <router-link class="nav-link" to="/"><img src="img/64px_Vue.js_Logo_2.svg" alt="Vue.js" /></router-link>
          </li>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item"><router-link class="nav-link" to="/">React</router-link></li>
              <li class="nav-item"><router-link class="nav-link" to="/issues">Problemi con React</router-link></li>
              <li class="nav-item"><router-link class="nav-link" to="/restaurants"> Menu di ristornati letta da json </router-link></li>
              <li class="nav-item"><router-link class="nav-link" to="/happyBar"> Menu fastfood con carrello </router-link></li>
              <li class="nav-item"><router-link class="nav-link" to="/about">Informazioni</router-link></li>
              <li class="nav-item" id="cart" style="display: none">
                <button class="btn btn-secondary" type="button" data-bs-toggle="offcanvas" data-bs-target="#order" aria-controls="order"><i class="bi bi-cart"></i> Ordine</button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <a id="document"></a>

      <main>
        <section class="document">
          <h1>L'evoluzione e l'impatto di React nel Modern Web Development.</h1>

          <div class="row">
            <div class="col">
              <p>
                Nel panorama in rapida evoluzione che é il web development, React é emerso come una tecnologia che ha rivoluzionato il modo in cui i siti web e le applicazioni sono costruiti e manutenuti. Sviluppato da
                Facebook, React ha ottenuto una popolaritá immensa fin dalla dua creazione nel 2013, e il suo approccio innovativo per costruire user interfaces ha influenzato l'intera comunitá di sviluppo web.
              </p>
            </div>
          </div>

          <div class="row">
            <div class="col">
              <p>
                La Nascita di React e i suoi concetti chiave: React é nato per il bisogno di semplificare il processo di sviluppo di user interfaces complesse. React intoduce il concetto dei componenti riutilizzabili,
                permettendo ai sviluppatori di dividere la user interface in pezzi piú piccoli e maneggevoli. Il Virtual DOM (Document Object Model) é stata un'altra innovazione cruciale, permettendo a React di
                aggiornare efficentemente solamente le parti necessarie di una pagina web quando i dati cambiano, cosí minimizzando il bisogno di ricare l'intera pagina.
              </p>
            </div>
            <div class="col">
              <p>
                Sviluppo dichiarativo(Declarative) e Component-Based: Uno dei principi fondamentali di React é la sua natura dichiarativo. Gli sviluppatori decrivono come l'UI dovrebbe essere in in qualunque momento,
                React si prende cura di aggiornare la UI che corrisponde allo stato desiderato. Questo approccio semplifica lo sviluppo astraendo le complessitá della monipolazione manuale del DOM.
              </p>
            </div>
            <div class="col">
              <p>
                L'architettura component-based offerta da React promuove riusabilitá e modularitá. Gli sviluppatori possono creare compomenti incapsulati che gestiscono i loro stessi stati e che possono essere facilmente
                combinati per creare interfacce complesse. Questo incoraggia una codebase piú organizzata e manutenibile.
              </p>
            </div>
            <div class="col">
              <p>
                Flux Architecture e State Management: React introduce la pattern Flux architecture , che influenza lo sviluppo delle librerie di state management come Redux. Gestire gli stati delle applicazioni puó
                diventare oneroso se le applicazioni crescono in complessitá. Il flusso di dati unidirezionale di React in combinazione con le librerie di management libraries é stato provato efficente nel mantenere uno
                stato di debug semplice e predicibile.
              </p>
            </div>
            <div class="col">
              <p>
                L'ascesa dell'ecosistema di React: La popolaritá di React a incentivato la crescita di un ricco ecosistema di strumenti e librerie. React Router per gestire la navigazione, Styled Components per
                component-oriented design e Axios per creare richieste API. La disponibilitá di questi strumenti semplifica lo sviluppo e mantiene un alto livello di consistenza nel progetto.
              </p>
            </div>
            <div class="col">
              <p>
                React Native e sviluppo Cross-Platform: L'influenza di React si espande oltre il Web con l'introduzione di React Native. Questo framework permette ai sviluppatori di costruire applicazioni native mobile
                usando lo stesso principio di sviluppo component-based. Condividendo una porzione significativa di codice tra web e piattaforme mobile React Native migliora l'efficenza e riduce il tempo di sviluppo.
              </p>
            </div>
            <div class="col">
              <p>
                Difficoltá e adattamenti: Per quanto React ha portato numerosi benefici allo sviluppo Web, non é senza le sue difficoltá. Imparare react e il suo ecosistema puó essere difficile per dei principianti per
                via del rapido cambio di marcia e della quantitá di concetti da comprendere. Oltretutto gestire lo stato di applicazioni grandi puó diventare complesso, portando a adottare soluzioni di state management
                piu' avanzate.
              </p>
            </div>
          </div>

          <div class="row">
            <div class="col">
              <p>
                Il viagggio di React dalla sua creazione a diventare una delle fondamenta dello sviluppo web e mobile moderno dimostra il potere dell'innovazione e della collaborazione della comunitá. L'enfasi della
                dichiarativitá, architettura component-based ha trasformato il modo in cui gli sviluppatori costruiscono le interfacce utente. con l'evoluzione dell'ecosistema di React, il suo impatto nell'industria
                rimane profondo, promettendo altri sviluppi negli anni a venire.
              </p>
            </div>
          </div>

          <h2>React JSX Structure and Example:</h2>

          <div class="row">
            <div class="col">
              <p>
                JSX (JavaScript XML) e' una estensione di sintassi usata in React che permette di scrivere codice HTML-like in JavaScript. E' una parte fondamentale dell'archittetura component-based di React, rendendo
                piu' facile descrivere la struttura dell'user interface. JSX Structure: In JSX si possono scrivere elementi HTML-like direttamnete nel codice JavaScript. Questi componenti sono trasformati in elementi
                React durante il processo di compilazione. La sintassi JSX assomiglia a HTML ma ci sono alcune differenze e regole da tenere a mente:
              </p>
            </div>
            <div class="col">
              <p>
                Elementi JSX devono avere un singolo elemento root. Non puoi avere piú elementi root nello stesso lovello. Attributi HTML sono creati usando camelCase invece di kebab-case (e.g., className invece di
                class-name). Si possono scrivere espressioni JavaScript tra parentesi graffe {}.
              </p>
            </div>
          </div>

          <div class="row">
            <div class="col">
              <p>Esempio: Creiamo un semplice componente React usando JSX. Creremo un componente HelloWord che faccia vedere un messaggio di saluto.</p>
            </div>
            <div class="col">
              <pre>
                <code class="language-react">
                import React from "react";

                // Defining a functional component using JSX
                function HelloWorld() {
                  const name = "John";
                  const greeting = "Hello,";

                  return (
                    &ltdiv&gt
                      &lth1&gt
                        {greeting} {name}!
                      &lt/h1&gt
                      &ltp&gtThis is a simple React JSX example.&lt/p&gt
                    &lt/div&gt
                  );
                }

                export default HelloWorld;
                </code>
              </pre>
            </div>
          </div>

          <div class="row">
            <div class="col">
              <p>
                In questo esempio: Importiamo la libreria React perché JSX viene trasformato in chiamate React.createElement(). Il componente HelloWorld é definito come una funzione. Dentro la dichiarazione return, si
                usa JSX per creare gli elementi dell'interfaccia utente. Le parentesi graffe {} permettono di inserire del contenuto dinamico (JavaScript expressions) dentro il JSX. La sintassi JSX permette di scrivere
                la struttura HTML-like direttamente con il codice dei componenti. Quando il componente é renderizzato produrrá un HTML simile ha:
              </p>
            </div>
            <div class="col">
              <div class="code">
                <h1>Hello, John!</h1>
                <p>This is a simple React JSX example.</p>
              </div>
            </div>
            <div class="col">
              <p>
                Ricordiamo che JSX necessita di essere compilato prima che venga usato nel browser. Questa compilazione vienen normalmente gestita da strumenti come Babel, questi convertono JSX in codice JavaScript
                standard che il browser puó capire. A conti fatti, JSX semplifica il processo di creare e gestire interfacce utente in React permettendo agli sviluppatori di esprimenre elementi della UI in maniera piú
                naturale dentro il loro codice JavaScript.
              </p>
            </div>
          </div>

          <h2>Struttura dei componenti React.</h2>

          <div class="row">
            <div class="col">
              <p>
                La struttura dei componenti React comprende l'organizzazione del codice e dei files in modo da promuovere chiarezza, modularitá e manutenibilitá. Anche se non c'é una regola precisa su come strutturare un
                componente React, esistono pratiche comuni che molti sviluppatori seguono. Questa é una struttura raccomandata:
              </p>
            </div>
            <div class="col">
              <ul>
                <li>ComponentName.js # Main component code</li>
                <li>ComponentName.css # Component-specific styles (optional)</li>
                <li>ComponentName.test.js # Component tests (optional)</li>
                <li>index.js # Exports the component for easier imports</li>
                <li>README.md # Component documentation (optional)</li>
              </ul>
            </div>
            <div class="col">
              <p>
                ComponentName.js: Questo é il file principale che contiene il codice del componente. Dovrebbe definire le funzionalitá del componente, interpretazione della logica e un qualunque stato e prop associato.
              </p>
            </div>
            <div class="col">
              <p>
                ComponentName.css (optional): Se il componente necessita stili specifici, si possono creare file CSS separati per quello. Questo aiuta a mantenere stati modulari e facili da gestire. Si potrebbe anche
                considerare usare soluzioni CSS-in-JS o moduli CSS.
              </p>
            </div>
            <div class="col">
              <p>
                ComponentName.test.js (optional): Se si sta seguendo test-driven development o semplicemente ci si vuole assicurare che il componente si comporti come previsto, si puó creare file di test usando framework
                di test come Jest e React Testing Library.
              </p>
            </div>
            <div class="col">
              <p>index.js: questo file é usato per esportare componenti, rendendo piú facile importarli in altre parti dell'applicazione. Questo permette di usare named imports e semplificare l'importazione.</p>
            </div>
            <div class="col">
              <p>
                README.md (optional): Scrivere una breve descrizione dello scopo, uso e ogni nota importante del componente in un file README puó essere utile per lo sviluppatore e altri che potrebbero usare il
                componente in futuro.
              </p>
            </div>
          </div>

          <div class="row">
            <div class="col">
              <p>Esempio: Creiamo una semplice struttura del componente Button sequendo le convenzione precedenti:</p>
            </div>
            <div class="col">
              <ul>
                <li>Button.js</li>
                <li>Button.css</li>
                <li>Button.test.js</li>
                <li>index.js</li>
              </ul>
            </div>
            <div class="col">
              <p>Button.js:</p>
              <pre>
                <code class="language-javascript">
                  import React from "react";
                  import "./Button.css";

                  function Button(props) {
                    const { label, onClick } = props;

                    return (
                      &ltbutton className="button" onClick={onClick}&gt
                        {label}
                      &lt/button&gt
                    );
                  }

                  export default Button;
                </code>
              </pre>
            </div>
            <div class="col">
              <p>Button.css:</p>
              <pre>
                <code class="language-css">
                .button {
                  padding: 10px 20px;
                  background-color: #007bff;
                  color: #ffffff;
                  border: none;
                  cursor: pointer;
                }
                </code>
              </pre>
            </div>
            <div class="col">
              <p>index.js:</p>
              <pre>
                <code class="language-javascript">
                import Button from "./Button";

                export default Button;
                </code>
              </pre>
            </div>
            <div class="col">
              <p>Now, you can easily import the Button component using:</p>
              <pre>
                <code class="language-javascript">
                import Button from "./Button";
                </code>
              </pre>
            </div>
            <div class="col">
              <p>Aderendo a una struttura del componente , si puó assicurare che il codice rimanga organizzato, manutenibile e facile da lavorarci con il crescere dell'applicazione.</p>
            </div>
          </div>

          <h2>React, come ci compongono i componenti.</h2>

          <div class="row">
            <div class="col">
              <p>
                Comporre componente in react involve combinare componenti piccoli e riusabili insieme per creare un interfaccia grande e piú complessa. Questo é possibile eseguendo componenti figlio con componenti padre
                JSX. Questa é una guida passo a passo su come comporre componente in React:
              </p>
            </div>
            <div class="col">
              <p>
                Creare componenti riusabili: Iniziare dal creare componneti individuali che incapsulino parti specifiche della UI o una funzionalitá. Ogni componente dovrebbe idealmente avere solo una responsabilitá.
                Questo promuove riusabilitá e manutenibilitá.
              </p>
            </div>
            <div class="col">
              <p>
                Componeneti annidati in JSX: Per creare componenti, si puó rendere in componente figlio dentro il JSX di un componnete padre. Usare semplicemente il nome del componente figlio come se fosse un componente
                HTML dentro il JSX del componente padre.
              </p>
            </div>
            <div class="col">
              <p>
                Passare dati con i prop: Per rendere i componenti composti piú dinamici si possono passare dati da componente padre a figlio usando prop (properties). I prop permettono di mandare informazioni ai
                componenti figlio, permettendogli di eseguire con i dati recepiti.
              </p>
            </div>
            <div class="col">
              <p>
                Esempio di composizione di componenti: Illustriamo il processo con un semplice esempio. Supponendo di avere un componente User che visualizza informazioni sll'utente e un componente UserProfile che usa il
                componente User per visualizzare altri profili.
              </p>
            </div>
            <div class="col">
              <pre>
                <code class="language-javascript">
                // User.js
                import React from 'react';

                function User(props) {
                return (
                &ltdiv className="user"&gt
                &lth3&gt{props.name}&lt/h3&gt
                &ltp&gtEmail: {props.email}&lt/p&gt
                &lt/div&gt
                );
                }

                export default User;

                // UserProfile.js
                import React from 'react';
                import User from './User';

                function UserProfile() {
                return (
                &ltdiv className="user-profile"&gt
                &lth2&gtUser Profile&lt/h2&gt
                &ltUser name="John Doe" email="john@example.com" /&gt
                &lt/div&gt
                );
                }

                export default UserProfile;
                </code>
              </pre>
            </div>
            <div class="col">
              <p>
                In questo esempio: Il componente User visualizza le informazioni dell'utente basato sulle proprietá ricevute. Il componente UserProfile é un componente padre che compone il componente User per creare la
                pagina profile dell'utente.
              </p>
            </div>
            <div class="col">
              <p>Quando si usa il componente UserProfile nell'applicazione, renderizzerá il componente User dentro di se:</p>
            </div>
            <div class="col">
              <pre>
                <code class="language-javascript">
                // App.js
                import React from "react";
                import UserProfile from "./UserProfile";

                function App() {
                  return (
                    &ltdiv className="app"&gt
                      &ltUserProfile /&gt
                    &lt/div&gt
                  );
                }

                export default App;

                </code>
              </pre>
            </div>
            <div class="col">
              Componendo e annidando componneti si possono costruire interfacce utente piú complesse mantenendo un codice piú modulare e organizzato. Questo approccio facilitá il riuso del codice, facilitá la leggibilitá
              e semplifica lo sviluppo e il mantenimento dell'applicazione React.
            </div>
          </div>

          <h2>Ciclo di vita dei componenti React.</h2>

          <div class="row">
            <div class="col">
              <p>
                In React i componenti hanno un ciclo di vita che consiste di varie fasi durante le quali il componente viene creato, aggiornato e eventualmente distrutto. Ma, con l'introduzione di React 16.3 e dopo, i
                cicli di vita tradizionali sono stati deprecati in favore dei nuovi "React Hooks" API, che provvedono a una gestione piú flessibile e coesiva della logica dei componenti. Quí si coprirá sia il ciclo di
                vitá tradizionale che i React Hooks. Cicli di vita tradizionali (React 16.2 e precedenti):
              </p>
            </div>
            <div class="col">
              <p>
                Mounting Phase: constructor(): Inizializzare il componente, settare lo stato iniziale e i vincoli. componentWillMount(): Deprecato, chiamato prima che il componente venga eseguito per la prima volta.
                render(): Eseque i componenti della UI. componentDidMount(): Invocato dopo che il componente é stato e seguito per la prima volta. Usato per effetti secondari come il recupero dei dati o interazioni con
                il DOM.
              </p>
            </div>
            <div class="col">
              <p>
                Updating Phase: componentWillReceiveProps(nextProps): Deprecato, chiamato quando il componente riceve nuove proprietá prima di aggiornarsi. shouldComponentUpdate(nextProps, nextState): Determina se il
                componete debba aggiornarsi, migliorando le prestazioni prevenendo esecuzioni inutili. componentWillUpdate(nextProps, nextState): Deprecato, chiamato prima che il componente di aggiorni. render():
                Ricarica la UI del componente con lo stato e le proprietá aggiornate. componentDidUpdate(prevProps, prevState): Invocato dopo che il componente si a aggiorna. Usato per gli effetti secondari dopo
                l'aggiornamento.
              </p>
            </div>
            <div class="col">
              <p>Unmounting Phase: componentWillUnmount(): Invocato prima che un componente sia rimosso dal DOM. Usata per i metodi di pulizia quando rimuovono event listeners.</p>
            </div>
          </div>

          <div class="row">
            <div class="col">
              <p>React Hooks (React 16.8 e dopo): React Hooks permettono un modo piú consistente e semplificato per gestire i cicli di vita dei componenti e lo stato logico dentro i componenti funzionali.</p>
            </div>
            <div class="col">
              <p>
                State Management: useState: Gestisce stati dei componenti senza usare stati class-based. useEffect: Esegue effetti secondari (data fetching, interazione con il DOM) nei componenti funzionali. Simili a
                componentDidMount e componentDidUpdate. useContext: Accede al contesto dentro ai componenti funzionali.
              </p>
            </div>
            <div class="col">
              <p>
                Other Hooks: useReducer: Gestisce lo stato logico usando una funzione di riduzione. useCallback and useMemo: Ottimizza l'esequzione memorizzando funzioni e valori. useRef: Prende un oggetto di riferimento
                mutabile che persiste attraverso i lettori.
              </p>
            </div>
            <div class="col">
              <p>
                Con i React Hooks, non c'é bisogno di preoccuparsi dell'esatto ciclo di vita da usare in situazioni diverse. Hooks offrono un modo piú intuitivo e unificato di gestire il comportamento dei componenti,
                rendendo il codice piú facile da capire e manutenere.
              </p>
            </div>
            <div class="col">
              <p>
                Tirando le somme, mentre i metodi del ciclo di vita tradizionale sono ancora applicabili per React 16.2 e prima, React Hooks provvedono un approccio piú moderno e flessibile per gestire la logica dei
                componenti e le interazioni tra i componenti funzionali. Sono diventati il modo proferito per lavorare con il cicli di vita dei componenti nelle versioni recenti di React.
              </p>
            </div>
          </div>

          <h2>React useState</h2>

          <div class="row">
            <div class="col">
              <p>
                useState é un React Hook che permette ai componenti funzionali di gestire lo stato senza usare componenti classe. Fá parte dei React Hooks API introdotti in React 16.8, e permette di aggiungere stateful
                behavior ai componenti mentre si sta ancora usando la semplicitá e componibilitá dei componenti funzionali.
              </p>
            </div>
            <div class="col">
              <p>
                Uso: Per usare useState hook, bisogna importarlo dalla libreria React e chiamarlo dentro il componente. Ritorna un array di due elementi: il valore dello stato corrente e una funzione per aggiornare lo
                stato del valore.
              </p>
            </div>
            <div class="col">
              <p>Questa é la sintassi di base:</p>
              <pre>
                <code class="language-javascript">
                import React, { useState } from "react";

                function Counter() {
                  // Declare a state variable named 'count' with initial value 0
                  const [count, setCount] = useState(0);

                  return (
                    &ltdiv&gt
                      &ltp&gtCount: {count}&lt/p&gt
                      &ltbutton onClick={()=&gt setCount(count + 1)} &gt Increment&lt/button&gt
                      &ltbutton &gt&lt/button&gt
                    &lt/div&gt
                  );
                }

                export default Counter;
                </code>
              </pre>
            </div>
            <div class="col">
              <p>
                In questo esempio lo useState hook é usato per creare una variabile di stato chiamata count con un valore iniziale di 0. La funzione setCount ritornata da useState é usata per aggiornare lo stato di
                count. Quando il bottone é cliccato, lo stato di count é incrementato di 1.
              </p>
            </div>
            <div class="col">
              <p>Punti chiave:</p>
              <ul>
                <li>Si puó usare useState piú volte in un singolo componente per gestire pezzi di stato differenti.</li>
                <li>L'argomento passato da useState é il valore iniziale dello stato.</li>
                <li>Le variabili di stato gestite da useState sono indipendenti e non si influenzano a vicenda.</li>
                <li>L'aggiornamento allo stato fatto usando la funzione state setter (setCount) é asincrono. React raggruppa multipli aggiornamenti di stato per essere piú efficente.</li>
              </ul>
            </div>
            <div class="col">
              <p>
                useState é un hook fondamentale che permette di aggiungere la gestione dello stato ai componenti della funzione. E' essenziale per costruire interfavve utente dinamiche e interattive senza il bisogno di
                componenti class-based e i cicli di vita a loro associati.
              </p>
            </div>
          </div>

          <h2>React useEffect</h2>

          <div class="row">
            <div class="col">
              <p>
                useEffect é un React Hook che permette di eseguire effetti secondari nei componenti funzionali. E' uno dei hook piú usati e permette di gestire vari scenari come il recupero di dati, manipolazione del
                DOM, e iscrizioni. Lo useEffect hook rimpiazza le funzionalitá dei metodi dei cicli di vita come: componentDidMount, componentDidUpdate e componentWillUnmount.
              </p>
            </div>
            <div class="col">
              <p>
                Uso: Per usare useEffect hook si importa dalla libreria React e viene chiamato dentro il componente funzionale. Ha bisogno di due argomenti: una funzione che contenga il codice dell'effetto secondario e
                un array di dipendenze opzionale. La funzione verrá eseguita dopo ogni esecuzione se le dipendenze sono cambiate.
              </p>
            </div>
            <div class="col">
              <p>Questa é la sintassi di base:</p>
              <pre>
                <code class="language-javascript">
                import React, { useState, useEffect } from "react";

                function DataFetching() {
                  const [data, setData] = useState(null);

                  useEffect(() =&gt {
                    // Fetch data or perform side effect here
                    // Update the 'data' state using setData
                    // This function will run after every render

                    // Return a cleanup function if needed (componentWillUnmount)
                    return () =&gt {
                      // Cleanup logic here
                    };
                  }, []); // Pass an empty array for no dependencies

                  return &ltdiv&gt{data ? &ltp&gtData: {data}&lt/p&gt : &ltp&gtLoading...&lt/p&gt}&lt/div&gt;
                }

                export default DataFetching;

                </code>
              </pre>
            </div>
            <div class="col">
              <p>
                In questo esempio l'useEffect hook é usato per prendere dati o eseguire un effetto secondario. Gira a ogni eseguzione, ma in questo caso, gira solo una volta perché un array vuoto [] é passato come la
                lista di dipendenze. Se si vuole che l'effetto giri ogni volta che un pezzo particolare di stato cambi si puó includere quello stato nell'array delle dipendenze. Per esempio, passare [count] farebbe
                partire l'effetto ogni volta che lo stato di count cambia.
              </p>
            </div>
            <div class="col">
              <p>
                Pulizia: Se l'effetto necessita di essere cancellato( come in componentWillUnmount), si puó ritornare un funzione di pulizia dall'effetto. Questa funzione sará eseguita quando il componente viene smontato
                o quando le dipendenze cambiano e l'effetto necessitá di essere riusato.
              </p>
            </div>
            <div class="col">
              <p>
                Nota: Se non si procura un array di dipendenze, l'effetto partirá dopo l'esecuzione, quella iniziale inclusa. Usando un array di dipendenze vuoto assicura che l'effetto parta solo una volta dopo
                l'esecuzione iniziale.
              </p>
            </div>
            <div class="col">
              <p>Casi di uso comune:</p>
              <ul>
                <li>Estrazioni di dati con APIs.</li>
                <li>Manipolazione del DOM.</li>
                <li>Iscrizioni e event listeners.</li>
                <li>Aggiornare i titoli dei documenti.</li>
                <li>Gestire animazioni e timer.</li>
              </ul>
            </div>
            <div class="col">
              <p>
                useEffect é un potente strumento per gestire effetti secondari dei componenti funzionali, rendendo il codice piú pulito e leggibile centralizzando la logica degli effetti secondari dentro i componenti.
              </p>
            </div>
          </div>
        </section>
      </main>

      <footer>
        <p>Triossi Edoardo - A.A. 2022/2023</p>
      </footer>
    </div>

    <!-- Application start -->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/vue@3"></script>
    <script src="https://unpkg.com/vue-router@4"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/prism.min.js"></script>
    <script src="index.js"></script>
  </body>
</html>
